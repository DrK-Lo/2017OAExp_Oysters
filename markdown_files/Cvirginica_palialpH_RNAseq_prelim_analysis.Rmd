---
title: "Cvirginica_palialpH_RNAseq_prelim_analysis"
author: "Brett Ford"
date: "5/30/2018"
output: html_document
---

```{r setup, include=FALSE}
library(knitr)
knitr::opts_chunk$set(tidy=TRUE, echo = TRUE)
```

## Preliminary Analysis of RNAseq count data

### Load libraries and import data
This code uses the raw count data and the filtered SNP data from RNAseq to identify preliminary patterns in the data.
Start by loading libraries required for the preliminary analysis. If the libraries do not properly load, make sure they are installed.
```{r}
source("http://bioconductor.org/biocLite.R")
library("edgeR")
library("limma")
library("statmod")
library("ggplot2")
```
Set the working directory:
```{r}
setwd("/Users/brettford/Desktop/Northeastern/lab_work/20180119_RNAseq_proj")
```

Read in the counts data table and the metadata table and view each
```{r}
GeneCounts <- read.delim("C_virginica_gene_count_final.txt", header=TRUE, sep="", row.names=1)
model<-read.delim("metadata_cvirginica_rna_meta.txt", header=TRUE)
head(GeneCounts)
head(model)
```

Now we want to filter out sequences with very low expression. Therefore, we will only keep sequences with more than 0.5 counts per million mapped reads across all 24 samples. To do this we calculate the counts per million per gene per indivdual. Then, if all individuals have a cpm greater than 0.5 for the gene, it is retained.
```{r}
keep <- rowSums(cpm(GeneCounts)>0.5) >=24
```

Create dataframe with only the loci we would like to keep. 
```{r}
y<- GeneCounts[keep,]
```

Check to see how many of the initial loci we maintained:
```{r}
dim(y)
percent_retained <- nrow(y)/nrow(GeneCounts)*100
print(paste("Percent retained:", percent_retained))
```

The percent retained (~11%) is much lower than the Wong paper received (~48%). May need to assess and compare methods to get count matrix.
Make sure the metadata table is sorted by individual, to correspond with the count matrix.
```{r}
model <- model[order(model$sample_name), ]
```

Create a factor that represents the treatments in the data. In this case that is the two different pCO2 levels at the two timepoints.
```{r}
f <- paste(paste0("pco", model$treatment), model$timepoint,sep=".")
f <- factor(f)
```

Create a model matrix of samples x treatment.
```{r}
design <-model.matrix(~0+f)
colnames(design) <- levels(f)
```

Create a DGEList object and apply TMM normalization to RNA-seq read counts.
```{r}
dge <- DGEList(counts=y, group=f)
dge <- calcNormFactors(dge)
```

Create an MDS plot to visualize the similarity of expression profiles between samples.
```{r}
#Specify colors you would like to use for the four treatments
colors <- rep(c("purple","blue","red","orange"))
# The plot parameters below are specific to this data, will likely need to change if working
# with other RNAseq data
plotMDS(dge, labels=rownames(dge$samples),cex=0.8, col=colors[f], xlim=c(-1.5, 1.5), ylim=c(-0.8, 0.8))
legend("bottomleft", legend = c(levels(dge$samples$group)), cex=0.8, col = c("purple","blue","red","orange"), lty = c(1, 1, 1, 1))

```

Voom transform the count data using voomWithQualityWeights function. Voom transformation log normalizes the cpm data.
```{r}
v1 <- voomWithQualityWeights(dge, design=design, lib.size=dge$samples$lib.size, plot = TRUE)
```

Remake the MDS plot, this time using the voom transformed dataframe.
```{r}
plotMDS(v1, labels=rownames(v1$targets),cex=0.8, col=colors[f], xlim=c(-1.5, 1.5), ylim=c(-0.8, 0.8))
legend("bottomleft", legend = c(levels(v1$targets$group)), cex=0.8, col = c("purple","blue","red","orange"), lty = c(1, 1, 1, 1))
```

Now we run voom again, this time adding a blocking variable and estimating correlation. We will block our samples by the tanks from which they came. This allows for there to be different variance between biological replicates, rather than calculating variance on a per-individual basis. In the Wong paper they considered samples taken from the same pCO2 vessel as a biological replicate. Here we consider any oyster taken from the same tank (tankID from unique shelf and tank combo) as biological replicates.

The correlation is input into the linear model fit.
```{r}
corfit <- duplicateCorrelation(v1,design,block=model$tankID)
corfit$consensus
v2 <- voomWithQualityWeights(dge,design,plot=TRUE,lib.size=dge$samples$lib.size,block=model$tankID,correlation=corfit$consensus)
```

Now remake the MDS plot with the v2-corrected data
```{r}
plotMDS(v2, labels=rownames(v2$targets),cex=0.8, col=colors[f], xlim=c(-1.5, 1.5), ylim=c(-0.8, 0.8))
legend("bottomleft", legend = c(levels(v2$targets$group)), cex=0.8, col = c("purple","blue","red","orange"), lty = c(1, 1, 1, 1))
```

Plot a PCA of the voom-corrected data:
```{r}
pcavoom<- prcomp(t(na.omit(v2$E)))
summary(pcavoom)
pca <- as.data.frame(prcomp(t(na.omit(v2$E)))$x)
pca$f<-f
shapes <- c(as.character(model$treatment))
pcaplot <- qplot(x=PC1, y=PC2, data=pca,colour=pca$f, size=I(4), shape=shapes)
pcaplot <- pcaplot + scale_colour_manual(values=c("purple","blue","red","orange"), breaks=c("pco400.3","pco400.6","pco2800.3","pco2800.6"), name=NULL, labels=c("400.3","400.6","2800.3","2800.6"))
pcaplot <- pcaplot + theme_bw()
pcaplot + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.title=element_text(size=14),legend.text=element_text(size=14),
                panel.background = element_blank(), axis.line = element_line(color = "black"), axis.text.y = element_text(angle = 90), legend.key = element_blank())

```

