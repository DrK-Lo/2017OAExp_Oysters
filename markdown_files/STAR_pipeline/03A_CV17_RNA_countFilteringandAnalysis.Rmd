---
title: "Gene Count Matrix Filtering and Exploration"
author: "adowneywall"
date: "April 9, 2019"
output: 
  html_document: 
    keep_md: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(kableExtra)
library(ggplot2)
```

#### **GeneCount matrix and oyster metadata table**  
```{r echo=TRUE}
# RNA count Matrix
GeneCounts <- read.delim("~/Github/2017OAExp_Oysters/results/C_virginica_gene_count_final.txt",header=TRUE,sep="",row.names=1)
```

```{r echo=FALSE}
## Exon Count Data
exons <- read.delim("~/Github/2017OAExp_Oysters/input_files/RNA/exon_count2.txt",header=TRUE,sep="",col.names = c("Locus","Gene","Count"))  
genes <- as.character(exons$Gene)
gene_split <- matrix(unlist(strsplit(genes,split = "-")),ncol=1)
```

**Top of Gene count matrix**  
```{r echo=FALSE}
kable(head(GeneCounts)) %>%
  kable_styling() %>% 
  scroll_box(width = "900px")
```

Total gene counts in data set  
```{r echo=FALSE}
# 
kable(rbind("Total Counts in Gene Count Matrix",sum(GeneCounts))) %>%
  kable_styling()
```

Number of total counts per individual  
```{r echo=FALSE}
# Number of total counts per individual
sum2 <- sapply(GeneCounts,sum)
kable(rbind(sum2)) %>%
  kable_styling() %>% 
  scroll_box(width = "900px")
```

#### **2017 Experiment MetaData**  
```{r}
# Oyster meta data
model<-read.delim("~/Github/2017OAExp_Oysters/input_files/RNA/metadata_cvirginica_rna_meta.txt",sep = ",",header=TRUE)
kable(model) %>%
  kable_styling() %>% 
  scroll_box(width = "900px", height = "400px")
```

####**Count Matrix Visualization**  
```{r,echo=FALSE}
# Histograms of all Counts
hist(unlist(GeneCounts),breaks=1000000,xlim=c(0,100),main="Histogram of All Counts (0-100 counts)",xlab="Count")
# Hard to see distribution of counts for all genes due to a handful of genes with high counts
#hist(exons$Count,breaks = 100000,main="Histogram will all Genes")
# Hist. for genes with counts between 1-1000
hist(exons$Count,xlim = c(0,1000),breaks=100000,main="Genes with counts between 1-1000")
# Still a little hard so lets look at it closer still (1-100)
hist(exons$Count,xlim = c(1,100),breaks=1000000,main="Genes with counts between 1-100")

# Lots of genes with small counts
# Table to look at proportion of reads in different size classes
count_classes <- c(0,1,2,5,10,25,50,100,200,250,500,1000,5000,10000,20000)
equal_greater_prob <- NULL
diff_prob <- NULL
for (i in 1:length(count_classes)) {
  equal_greater_prob[i] <-length(exons$Count[exons$Count >= count_classes[i] ])/length(exons$Count)
  if(i > 1){diff_prob[i] <- equal_greater_prob[c(i-1)] - equal_greater_prob[i]}
  else{diff_prob[i] <- 0}
}

count_class_df <- data.frame (Max_Count = count_classes,
                              Prob_Gene_less=equal_greater_prob,
                              Prob_Gene_greater=1-equal_greater_prob,
                              Prob_Change=diff_prob)

kable(count_class_df) %>%
  kable_styling() %>% 
  scroll_box(width = "900px")

gene_diagnostics <- data.frame(name = row.names(GeneCounts),
                            Total_Reads =rowSums(GeneCounts))
```

### **Data Exploration - Complete Gene Count Matrix**

**Examining low read count and potential lane bias**  
```{r echo=TRUE}
# Balanced Design - equal number of individuals from each treatment*time combination are in each lane
table(model$treatment,model$lane,model$timepoint)

### Looking at lane specific effects
# Isolate samples by lane
GC_lane1 <- GeneCounts[,model$lane == 1]
GC_lane2 <- GeneCounts[,model$lane == 2]
# Sum counts for each lane at each locus
GC_lane1_sum <- rowSums(GC_lane1)
GC_lane2_sum <- rowSums(GC_lane2)
# Ratio of the difference in read count between lanes for each gene feature 
GC_diff <- c(abs(GC_lane1_sum - GC_lane2_sum)+0.0001)/ c(GC_lane1_sum + GC_lane2_sum+0.0001)
hist(GC_diff,main="Lane Bias (0 = low lane bias, 1 = complete lane bias")

GC_lane1_mean <- apply(GC_lane1,1,median)
GC_lane2_mean <- apply(GC_lane2,1,median)
plot(log10(GC_lane1_mean+1)~log10(GC_lane2_mean+1),main="Median Lane Count")

gene_diagnostics$Difference_Ratio <- GC_diff
```

**Proportion of counts explained by a single individual**
```{r}
# Determining the largest number of reads per gene for a single individual
GC_max <- apply(GeneCounts,1,max)
prop_single_ind <- GC_max/rowSums(GeneCounts) 
hist(prop_single_ind,main="Max proportion of total gene count in a single individual")
gene_diagnostics$Prop_Single_Ind <- prop_single_ind
```

**Number of Samples with counts per gene**
```{r}
prop_with_count <- apply(GeneCounts, 1, function(c)sum(c!=0))
hist(prop_with_count/24,breaks=24,xlab="Prop_with_count",main="Proportion of individuals with at least one count of a gene")
gene_diagnostics$Prop_with_Count <- prop_with_count
```

**Variance of read counts (a measure of count spread cross all individuals)**
```{r}
# Theoritical max variance for each gene based on total counts per gene
max_var_mat <- matrix(ncol=24,nrow=length(GeneCounts$RNA17005),0)
max_var_mat[,1] <- c(GC_lane1_sum+GC_lane2_sum)
max_var <- apply(max_var_mat,1,var)
#Actual variance for each gene
gene_var <- apply(GeneCounts,1,var)
# Per gene variance scaled by theoritical maximum
Count_Variance <- gene_var/max_var
#hist(Count_Variance,main="Histogram Standardize Count Variance")
#plot(ecdf(Count_Variance),main="CDF Standardize Count Variance")
gene_diagnostics$Gene_Count_Variance = Count_Variance
```

**Plots**
```{r, echo=FALSE}
#ggplot(gene_diagnostics,aes(x = Prop_with_Count,y = Gene_Count_Variance)) + geom_point() + geom_smooth(method="auto")

#ggplot(gene_diagnostics,aes(x = Prop_Single_Ind,y = Gene_Count_Variance)) + geom_point() + geom_smooth(method="auto")

# ggplot(gene_diagnostics,aes(x = Prop_Single_Ind,y = Prop_with_Count)) + geom_point() + geom_smooth(method="auto")

# plot(GC_diff~c(GC_lane1_sum+GC_lane2_sum),xlim=c(0,1000),
#     main="Read count vs. Ratio of the difference in read count between lanes (per gene)",
#     xlab="Total Reads",
#     ylab="Difference Ratio")
# abline(h = 0.80,col="red") + abline(v = 10,col="red")

ggplot(gene_diagnostics,aes(x=Total_Reads,y=Difference_Ratio,colour=Prop_Single_Ind)) + geom_point() +
 labs(title="Read count vs. Ratio of the difference in read count between lanes (per gene)",
      x="Total Reads (per Gene)",y="Lane Bias (0 is no bias, 1 biased to one lane)") +
 xlim(0,1000)

#ggplot(gene_diagnostics,aes(x=Total_Reads,y=Difference_Ratio,colour=Gene_Count_Variance)) + geom_point() + 
#  labs(title="Read count vs. Ratio of the difference in read count between lanes (per gene)",
#       x="Total Reads (per Gene)",y="Lane Bias (0 is no bias, 1 biased to one lane)") +
#  xlim(0,1000)
``` 
  
###  Visualizing differential expression by treatment and time  

**Treatment**
```{r echo=TRUE}
### Isolate samples by treatment ###
GC_400 <- GeneCounts[,model$treatment == 400]
GC_2800 <- GeneCounts[,model$treatment == 2800]
# Sum counts for each treatment at each locus
GC_400_sum <- rowSums(GC_400)
GC_2800_sum <- rowSums(GC_2800)
# Ratio of the difference in read count between treatment for each gene feature 
GC_trt_diff <- c(abs(GC_400_sum - GC_2800_sum)+0.0001)/ c(GC_400_sum + GC_2800_sum+0.0001)
hist(GC_trt_diff,breaks=100)
gene_diagnostics$Difference_Trt <-  GC_trt_diff
```

**Time**
```{r}
### Isolate samples by Timepoint ###
GC_early <- GeneCounts[,model$timepoint == 3]
GC_late <- GeneCounts[,model$timepoint == 6]
# Sum counts for each treatment at each locus
GC_early_sum <- rowSums(GC_early)
GC_late_sum <- rowSums(GC_late)
# Ratio of the difference in read count between treatment for each gene feature 
GC_time_diff <- c(abs(GC_early_sum - GC_late_sum)+0.0001)/ c(GC_early_sum + GC_late_sum+0.0001)
hist(GC_time_diff,breaks =100)
gene_diagnostics$Difference_Time <-  GC_time_diff
```

**Treatment & Time**
```{r}
### Isolate samples by Timepoint ###
t9_400 <- c(model$timepoint == 3 & model$treatment == 400)
t9_2800 <- c(model$timepoint == 3 & model$treatment == 2800)
t80_400 <- c(model$timepoint == 80 & model$treatment == 400)
t80_2800 <- c(model$timepoint == 80 & model$treatment == 2800)

GC_1 <- GeneCounts[,t9_400]
GC_2 <- GeneCounts[,t9_2800]
GC_3 <- GeneCounts[,t80_400]
GC_4 <- GeneCounts[,t80_2800]

# Median for each treatment at each locus
GC_1_median <-  apply(GC_1,1,median)
GC_2_median <-  apply(GC_2,1,median)
GC_3_median <-  apply(GC_3,1,median)
GC_4_median <-  apply(GC_4,1,median)

# Means
# Sum counts for each treatment at each locus
GC_1_mean <-  apply(GC_1,1,mean)
GC_2_mean <-  apply(GC_2,1,mean)
GC_3_mean <-  apply(GC_3,1,mean)
GC_4_mean <-  apply(GC_4,1,mean)



```

**Gene Table with summary statistics**  
```{r}
kable(count_class_df)
```

### Filtering  

**Criteria**
```{r}
# Count Threshold
CT <-  10
PMAX <-  0.8
```

```{r,eval=FALSE}
### Updates Dataframe with T/F based on specific filtering criterion

# Counts
gene_diagnostics$CT <- c(gene_diagnostics$Total_Reads < 10)
# Single Ind Max
gene_diagnostics$PMAX <- c(gene_diagnostics$Prop_Single_Ind < 0.8)
```

#### **Filtering Scenarios**  
**Scenario 1**: CT and PMAX  
```{r}
scenario1_crit <- c(CT,PMAX)
scenario1 <-GeneCounts[c(gene_diagnostics$CT & gene_diagnostics$PMAX),]
```

**Filtering Summary**
```{r}
# filter_sum <- data.frame(Name="Original",
#                          CT=0,
#                          PMAX=0,
#                          Genes=nrow(GeneCounts),
#                          Gene_Per=100,
#                          Counts=sum(GeneCounts),
#                          Counts_Per=100)
# (s1_gene <- nrow(scenario1)/nrow(GeneCounts)*100)
# (s1_gene_per <- nrow(scenario1)/nrow(GeneCounts)*100)
# (s1_count <- sum(scenario1))
# (s1_count_per <- sum(scenario1)/sum(GeneCounts)*100)

#s1 <- rbind(filter_sum,cbind("Scenario1",CT,PMAX,s1_gene,s1_gene_per,s1_count,s1_count_per))
```


### OUTDATED: Using CPM to further filter genes with low coverage

One final filtering step, we want to filter out sequences with very low expression. Therefore, we will **only keep** sequences with more than **0.5 counts per million mapped reads across all 24 samples**. To do this we calculate the counts per million (CPM) per gene per indivdual. Then, if all individuals have a CPM greater than 0.5 for the gene, it is retained.   
```{r,eval=FALSE}
## Function CPM in package edgeR, takes countMatrix and normalizes it as counts per million
# Without removing exceptionally high read loci
perMilReads <- cpm(GeneCounts)

# Example of how cpm calculates the number of reads per million bases
GeneCounts$RNA17019[1]/sum(GeneCounts$RNA17019)*1*10^{6} # Manually calculate read per million at first locus in sample RNA17019
perMilReads[1,dimnames(perMilReads)[[2]] == "RNA17019"] # Calculate read per million at first locus in sample RNA17019 using cpm

## Only keep a locus if it was at least 0.5 million reads for all 24 individuals
keep <- row.names(perMilReads[rowSums(perMilReads>0.5) >=24,])


# Counts per million on pre filtered dataset (considering lane bias)
perMilReads_alt <- cpm(account_forCount) # cpm on pre filtered dataset
keep2 <- rowSums(perMilReads_alt>0.5) >=24

```

```{r,eval=FALSE, echo=FALSE}
Save subset in new dataframe and log transform counts.  
# Without log transformation
y <- GeneReduce2
#y<- account_forCount+0.01 #GeneCounts[keep,]
hist(rowMeans(y),breaks = 100,xlab = "Mean Count", main = "Histogram of mean counts for each locus") 

# With log2 transformation
yLog<- log2(y)
hist(rowMeans(yLog),breaks=100,xlab= "Mean log Count",main = "Histogram of log transformed mean counts for each locus")
pairs.panels(yLog[,1:6])
pairs.panels(yLog[,7:12])
pairs.panels(yLog[,13:18])
pairs.panels(yLog[,19:24])

**Note**: *The log transformed data shown illustrates how transforming data in this way helps will the heavily skewed RNA expression data. However, we will actually be log transforming the untransformed values at a later step using the package ```limm```, so we will proceed with the untransformed values for the time being.* 
```

```{r,eval=FALSE, echo=FALSE}
**Number of remaining loci after filtering:**  
# Number of total loci
nrow(y)
percent_retained <- nrow(y)/nrow(GeneCounts)*100
print(paste("Percent retained:", percent_retained))

** Notes on filtering**: The percent retained (~11%) is much lower than the Wong paper received (~48%). May need to assess and compare methods to get count matrix.  
```
  
